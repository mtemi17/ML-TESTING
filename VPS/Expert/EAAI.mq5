#property copyright "Generated by GPT-5 Codex"
#property version   "1.00"
#property strict

// ---------------------------------------------------------------------------
//  Opening Range Breakout EA with AI Probability Filter
//
//  DISCLAIMER:
//  This is a reference implementation. Review and adjust risk management,
//  order handling, and error trapping before use on live accounts.
//
//  REQUIREMENTS:
//  - Run the Python scoring service (ml_service.py) locally:
//        python3 ml_service.py
//    The service listens on http://127.0.0.1:8001/predict
//  - Enable "Allow WebRequest" in MT5 options and add:
//        http://127.0.0.1:8001
// ---------------------------------------------------------------------------

input double   InpRiskPercent         = 1.0;      // Risk percent per trade
input bool     InpUsePullback         = true;     // Enable pullback entries
input bool     InpUseReversal         = true;     // Enable reversal entries
input bool     InpUseEmaFilter        = true;     // Require EMA alignment
input double   InpRewardToRisk        = 2.0;      // Reward to risk multiple
input bool     InpUseAiFilter         = true;     // Gate trades using AI
input double   InpProbabilityThreshold= 0.50;     // AI probability threshold
input string   InpAiEndpoint          = "http://127.0.0.1:8001/predict";
input int      InpMaxTradesPerWindow  = 1;        // Max trades per window

// --- constants -------------------------------------------------------------
#define WINDOW_COUNT   3
string WindowTimes[WINDOW_COUNT] = {"03:00","10:00","16:30"};

// --- global state ----------------------------------------------------------
datetime g_lastWindowTrade[WINDOW_COUNT];
int      g_ma5Handle  = INVALID_HANDLE;
int      g_ma1hHandle = INVALID_HANDLE;

// structure to store window ranges
struct WindowRange
{
   datetime start;
   datetime end;
   double   high;
   double   low;
   string   id;
};

// ---------------------------------------------------------------------------
int OnInit()
{
   // initialize last trade timestamps
   for(int i=0;i<WINDOW_COUNT;i++)
      g_lastWindowTrade[i] = 0;

   // allow only on 5-minute charts
   if(Period() != PERIOD_M5)
   {
      Print("Please attach the EA on a 5-minute chart.");
      return(INIT_PARAMETERS_INCORRECT);
   }

   g_ma5Handle  = iMA(_Symbol, PERIOD_M5, 200, 0, MODE_EMA, PRICE_CLOSE);
   g_ma1hHandle = iMA(_Symbol, PERIOD_H1, 200, 0, MODE_EMA, PRICE_CLOSE);
   if(g_ma5Handle == INVALID_HANDLE || g_ma1hHandle == INVALID_HANDLE)
   {
      Print("Failed to create MA handles.");
      return(INIT_FAILED);
   }

   return(INIT_SUCCEEDED);
}

// ---------------------------------------------------------------------------
void OnDeinit(const int reason)
{
   if(g_ma5Handle != INVALID_HANDLE)
      IndicatorRelease(g_ma5Handle);
   if(g_ma1hHandle != INVALID_HANDLE)
      IndicatorRelease(g_ma1hHandle);
}

// ---------------------------------------------------------------------------
void OnTick()
{
   static datetime lastBarTime = 0;
   datetime currentBarTime = iTime(_Symbol, PERIOD_M5, 0);
   if(currentBarTime == lastBarTime)
      return;
   lastBarTime = currentBarTime;

   // evaluate each window
   for(int w=0; w<WINDOW_COUNT; w++)
   {
      WindowRange range;
      if(!GetWindowRange(w, range))
         continue;

      // skip if already traded
      if(CountTradesForWindow(range.id) >= InpMaxTradesPerWindow)
         continue;

      // check trading window active
      datetime now = TimeCurrent();
      if(now < range.start || now > range.end)
         continue;

      // evaluate signals
      bool pullbackSignal=false;
      bool reversalSignal=false;
      double entryPrice=0, stopPrice=0, targetPrice=0;
      string entryType="";

      if(InpUsePullback)
         pullbackSignal = CheckPullback(range, entryPrice, stopPrice, targetPrice, entryType);

      if(!pullbackSignal && InpUseReversal)
         reversalSignal = CheckReversal(range, entryPrice, stopPrice, targetPrice, entryType);

      if(!(pullbackSignal || reversalSignal))
         continue;

      if(InpUseEmaFilter && !CheckEmaFilter(entryType))
         continue;

      if(InpUseAiFilter)
      {
         double probability;
         if(!QueryAiProbability(range, entryType, entryPrice, stopPrice, targetPrice, probability))
         {
            Print("AI service unreachable; skipping trade.");
            continue;
         }
         if(probability < InpProbabilityThreshold)
         {
            PrintFormat("AI probability %.2f below threshold %.2f, skipping.",
                        probability, InpProbabilityThreshold);
            continue;
         }
      }

      // calculate lot size
      double lots = CalculatePositionSize(entryPrice, stopPrice);
      if(lots <= 0)
      {
         Print("Lot size is zero; check risk parameters.");
         continue;
      }

      // send order
      bool tradeOpened = OpenTrade(entryPrice, stopPrice, targetPrice, entryType, range.id, lots);
      if(tradeOpened)
         g_lastWindowTrade[w] = now;
   }
}

// ---------------------------------------------------------------------------
bool GetWindowRange(int index, WindowRange &range)
{
   datetime today = DateOfDay(iTime(_Symbol, PERIOD_M5, 0));
   string timeStr = WindowTimes[index];
   string dateStr = TimeToString(today, TIME_DATE);
   datetime windowStart = StringToTime(dateStr+" "+timeStr);
   datetime windowEnd   = windowStart + 15*60 - 1;
   datetime tradeEnd    = windowStart + 3*60*60; // 3 hours

   int startIndex = iBarShift(_Symbol, PERIOD_M5, windowStart, true);
   if(startIndex < 0)
      return false;

   int endIndex = iBarShift(_Symbol, PERIOD_M5, windowEnd, true);
   if(endIndex < 0)
      endIndex = 0;

   double highest = -DBL_MAX;
   double lowest  =  DBL_MAX;
   for(int i=endIndex; i<=startIndex; i++)
   {
      highest = MathMax(highest, iHigh(_Symbol, PERIOD_M5, i));
      lowest  = MathMin(lowest,  iLow(_Symbol, PERIOD_M5, i));
   }

   range.start = windowStart + 15*60; // trading window starts after range completes
   range.end   = tradeEnd;
   range.high  = highest;
   range.low   = lowest;
   range.id    = StringFormat("%s_%s", dateStr, timeStr);
   return true;
}

// ---------------------------------------------------------------------------
int CountTradesForWindow(const string &windowId)
{
   int total=0;
   HistorySelect(TimeCurrent()-86400*5, TimeCurrent());
   uint deals = HistoryDealsTotal();
   for(uint i=0;i<deals;i++)
   {
      ulong ticket = HistoryDealGetTicket(i);
      string comment = HistoryDealGetString(ticket, DEAL_COMMENT);
      if(StringFind(comment, windowId) >= 0)
         total++;
   }
   return total;
}

// ---------------------------------------------------------------------------
bool CheckPullback(const WindowRange &range, double &entryPrice, double &stopPrice,
                   double &targetPrice, string &entryType)
{
   // placeholder signal logic (requires refinement)
   double close = iClose(_Symbol, PERIOD_M5, 1);
   double low   = iLow  (_Symbol, PERIOD_M5, 1);
   double high  = iHigh (_Symbol, PERIOD_M5, 1);

   // bullish pullback: breakout above range, then retest
   if(close > range.high && low <= range.high)
   {
      entryPrice  = range.high;
      stopPrice   = range.low;
      targetPrice = entryPrice + InpRewardToRisk*(entryPrice - stopPrice);
      entryType   = "PULLBACK_LONG";
      return true;
   }

   // bearish pullback
   if(close < range.low && high >= range.low)
   {
      entryPrice  = range.low;
      stopPrice   = range.high;
      targetPrice = entryPrice - InpRewardToRisk*(stopPrice - entryPrice);
      entryType   = "PULLBACK_SHORT";
      return true;
   }

   return false;
}

// ---------------------------------------------------------------------------
bool CheckReversal(const WindowRange &range, double &entryPrice, double &stopPrice,
                   double &targetPrice, string &entryType)
{
   // placeholder for two-candle confirmation logic
   double close = iClose(_Symbol, PERIOD_M5, 1);
   double open  = iOpen (_Symbol, PERIOD_M5, 1);
   double prevClose = iClose(_Symbol, PERIOD_M5, 2);
   double prevOpen  = iOpen (_Symbol, PERIOD_M5, 2);

   // bearish reversal after false breakout above range
   if(prevClose > range.high && close < open && prevClose > prevOpen)
   {
      entryPrice  = (close + prevClose)/2.0;
      stopPrice   = MathMax(iHigh(_Symbol, PERIOD_M5, 1), iHigh(_Symbol, PERIOD_M5, 2));
      targetPrice = entryPrice - InpRewardToRisk*(stopPrice - entryPrice);
      entryType   = "REVERSAL_SHORT";
      return true;
   }

   // bullish reversal after false breakout below range
   if(prevClose < range.low && close > open && prevClose < prevOpen)
   {
      entryPrice  = (close + prevClose)/2.0;
      stopPrice   = MathMin(iLow(_Symbol, PERIOD_M5, 1), iLow(_Symbol, PERIOD_M5, 2));
      targetPrice = entryPrice + InpRewardToRisk*(entryPrice - stopPrice);
      entryType   = "REVERSAL_LONG";
      return true;
   }

   return false;
}

// ---------------------------------------------------------------------------
bool CheckEmaFilter(const string &entryType)
{
   double ema5 = GetMAValue(g_ma5Handle, 1);
   double ema1h = GetMAValue(g_ma1hHandle, 0);
   double price = iClose(_Symbol, PERIOD_M5, 1);

   bool bullish = (entryType == "PULLBACK_LONG" || entryType == "REVERSAL_LONG");
   bool bearish = (entryType == "PULLBACK_SHORT" || entryType == "REVERSAL_SHORT");

   if(bullish && (price < ema5 || price < ema1h))
      return false;
   if(bearish && (price > ema5 || price > ema1h))
      return false;
   return true;
}

// ---------------------------------------------------------------------------
double CalculatePositionSize(double entryPrice, double stopPrice)
{
   double riskMoney = AccountInfoDouble(ACCOUNT_BALANCE) * InpRiskPercent/100.0;
   double stopDistance = MathAbs(entryPrice - stopPrice);
   if(stopDistance <= 0.0)
      return 0.0;

   double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   if(tickSize <= 0 || tickValue <= 0)
      return 0.0;

   double valuePerLot = stopDistance / tickSize * tickValue;
   if(valuePerLot <= 0.0)
      return 0.0;

   double lots = riskMoney / valuePerLot;
   double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   double minLot  = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot  = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);

   lots = MathFloor(lots/lotStep)*lotStep;
   lots = MathMax(lots, minLot);
   lots = MathMin(lots, maxLot);
   return lots;
}

// ---------------------------------------------------------------------------
bool OpenTrade(double entryPrice, double stopPrice, double targetPrice,
               const string &entryType, const string &windowId, double lots)
{
   int type = ORDER_TYPE_BUY;
   if(entryType == "PULLBACK_SHORT" || entryType == "REVERSAL_SHORT")
      type = ORDER_TYPE_SELL;

   MqlTradeRequest request;
   MqlTradeResult  result;
   ZeroMemory(request);
   ZeroMemory(result);

   request.action   = TRADE_ACTION_DEAL;
   request.symbol   = _Symbol;
   request.volume   = lots;
   request.deviation= 50;
   request.comment  = StringFormat("%s_%s", entryType, windowId);
   request.magic    = 123456;
   request.type     = type;
   request.price    = (type == ORDER_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_ASK)
                                               : SymbolInfoDouble(_Symbol, SYMBOL_BID);
   request.sl       = stopPrice;
   request.tp       = targetPrice;

   if(!OrderSend(request, result))
   {
      PrintFormat("OrderSend failed: %d", GetLastError());
      return false;
   }

   if(result.retcode != TRADE_RETCODE_DONE)
   {
      PrintFormat("OrderSend retcode: %d", result.retcode);
      return false;
   }

   return true;
}

// ---------------------------------------------------------------------------
bool QueryAiProbability(const WindowRange &range, const string &entryType,
                        double entryPrice, double stopPrice, double targetPrice,
                        double &probability)
{
   string json = BuildFeatureJson(range, entryType, entryPrice, stopPrice, targetPrice);
   uchar post[];
   int len = StringLen(json);
   ArrayResize(post, len);
   for(int i=0; i<len; i++)
      post[i] = (uchar)StringGetCharacter(json, i);

   uchar answer[];
   string responseHeaders;
   string headers = "Content-Type: application/json\r\n";
   ResetLastError();
   int status = WebRequest("POST", InpAiEndpoint, headers, 5000, post, answer, responseHeaders);
   if(status == -1)
   {
      PrintFormat("WebRequest failed: %d", GetLastError());
      return false;
   }
   if(status != 200)
   {
      PrintFormat("AI service HTTP status %d", status);
      return false;
   }

   char responseChars[];
   ArrayResize(responseChars, ArraySize(answer));
   for(int i=0;i<ArraySize(answer);i++)
      responseChars[i] = (char)answer[i];
   string response = CharArrayToString(responseChars, 0, ArraySize(responseChars));
   double value = ParseProbability(response);
   if(value < 0)
   {
      Print("Invalid AI response.");
      return false;
   }

   probability = value;
   return true;
}

// ---------------------------------------------------------------------------
string BuildFeatureJson(const WindowRange &range, const string &entryType,
                        double entryPrice, double stopPrice, double targetPrice)
{
   double risk = MathAbs(entryPrice - stopPrice);
   string direction = (entryType == "PULLBACK_LONG" || entryType == "REVERSAL_LONG") ? "BUY" : "SELL";

   string payload;
   payload += "{ \"features\": {";
   payload += StringFormat("\"EntryPrice\":%.6f,", entryPrice);
   payload += StringFormat("\"SL\":%.6f,", stopPrice);
   payload += StringFormat("\"TP\":%.6f,", targetPrice);
   payload += StringFormat("\"Risk\":%.6f,", risk);
   payload += StringFormat("\"RangeHigh\":%.6f,", range.high);
   payload += StringFormat("\"RangeLow\":%.6f,", range.low);
   payload += StringFormat("\"EntryType\":\"%s\",", entryType);
   payload += StringFormat("\"Type\":\"%s\",", direction);
   payload += StringFormat("\"WindowType\":\"%s\",", range.id);
   payload += StringFormat("\"WindowID\":\"%s\"", range.id);
   payload += "} }";
   return payload;
}

// ---------------------------------------------------------------------------
double ParseProbability(const string &json)
{
   int pos = StringFind(json, "probability");
   if(pos < 0)
      return -1.0;
   pos = StringFind(json, ":", pos);
   if(pos < 0)
      return -1.0;
   int end = StringFind(json, ",", pos);
   if(end < 0)
      end = StringFind(json, "}", pos);
   if(end < 0)
      end = StringLen(json);
   string value = StringSubstr(json, pos+1, end-pos-1);
   StringReplace(value, " ", "");
   StringReplace(value, "\"", "");
   return StringToDouble(value);
}

// ---------------------------------------------------------------------------
datetime DateOfDay(datetime dt)
{
   MqlDateTime tm;
   TimeToStruct(dt, tm);
   tm.hour=0; tm.min=0; tm.sec=0;
   return StructToTime(tm);
}

// ---------------------------------------------------------------------------
double GetMAValue(int handle, int shift)
{
   if(handle == INVALID_HANDLE)
      return 0.0;
   double buffer[];
   if(CopyBuffer(handle, 0, shift, 1, buffer) <= 0)
      return 0.0;
   return buffer[0];
}

